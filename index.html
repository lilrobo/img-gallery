<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Lilrobo AI-Generated Asset Pipeline Projects</title>
  <meta property="og:image" content="https://www.midjourney.com/app/jobs/241869ea-0219-4e5e-b7a0-67d9cf9bd98a/"/>
  <meta property="og:title" content="Lilrobo AI-Generated Asset Pipeline Projects" />
  <meta property="og:description" content="Lilrobo AI-Generated Asset Pipeline Projects" />
  <style>
    html {
      /* inline background noise. No network request/failure possible */
      background-image: url(data:image/png;base64,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);
      background-color: rgb(1 5 19);
      /*background: repeating-linear-gradient(#e66465 0%, #9198e5 5%);*/ /* for debugging background/scroll movement */
    }
    body {
      overflow-x: hidden;
    }
    .box {
      position: absolute;
      top: 0;
      left: 0;
      overflow: hidden;
      background-color: rgb(34, 36, 53);
      border-radius: 16px;
      box-shadow:
        0 0px 2px 0 rgba(255, 255, 255, 0.2),
        0 4px 28px 0 rgba(0, 0, 0, 0.4);
      background-size: 100%; /* low-res image added as background-image in JS later */
      background-repeat: no-repeat; /* just in case of floating point whatever */
    }
    .box img {
      display: block; /* prevent inline-block from adding whitespaces... */
      width: 100%;
      border-radius: 16px 16px 0 0; /* safari forgets border-radius occlusion from box container when lifting img onto GPU */
    }
    .prompt {
      position: absolute; /* rest near bottom even when image isn't loaded yet */
      width: 100%;
      box-sizing: border-box;
      padding: 8px 12px 0px 12px;
      font-family: "DM Sans", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; /* same as midjourney's */
      color: rgb(192, 198, 205);
      font-size: 16px;
      cursor: text; /* overrides document's cursor when needed (see JS code below) */
      /* for line clamping programmatically */
      display: -webkit-box;
      -webkit-box-orient: vertical;
    }
    .prompt:before {
      content: '// ';
      color: rgb(122, 126, 130);
      padding-right: 2px;
    }
  </style>
</head>

<body>
<script>
'use strict'

// === generic scheduler & its debugger
const debug = false // toggle this for manually stepping through animation frames (press key A)
let debugTimestamp = 0
const raf = debug ? function raf(f) {
  debugTimestamp += 1000 / 60
  f(debugTimestamp)
} : requestAnimationFrame

let scheduledRender = false
function scheduleRender(debugForceRender) {
  if (debug && !debugForceRender) return
  if (scheduledRender) return;
  scheduledRender = true

  raf(function renderAndMaybeScheduleAnotherRender(now) { // eye-grabbing debug name in the inspector. No (anonymous) arrow function please
    scheduledRender = false
    if (render(now)) scheduleRender()
  })
}

// === generic spring physics
// 4ms/step for the spring animation's step. Typically 4 steps for 60fps (16.6ms/frame) and 2 for 120fps (8.3ms/frame). Frame time delta varies, so not always true
// could use 8ms instead, but 120fps' 8.3ms/frame means the computation might not fit in the remaining 0.3ms, which means sometime the simulation step wouldn't even run once, giving the illusion of jank
const msPerAnimationStep = 4
function spring(pos, v = 0, k = 290, b = 30) {
  return {pos, dest: pos, v, k, b} // k = stiffness, b = damping. Try https://chenglou.me/react-motion/demos/demo5-spring-parameters-chooser/
}
function springStep(config) {
  // https://blog.maximeheckel.com/posts/the-physics-behind-spring-animations/
  // lol this totally seems copied from https://github.com/chenglou/react-motion/blob/9e3ce95bacaa9a1b259f969870a21c727232cc68/src/stepper.js
  const t = msPerAnimationStep / 1000 // convert to seconds for the physics equation
  const {pos, dest, v, k, b} = config
  // for animations, dest is actually spring at rest. Current position is the spring's stretched/compressed state
  const Fspring = -k * (pos - dest) // Spring stiffness, in kg / s^2
  const Fdamper = -b * v // Damping, in kg / s
  const a = Fspring + Fdamper // a needs to be divided by mass, but we'll assume mass of 1. Adjust k and b to change spring curve instead
  const newV = v + a * t
  const newPos = pos + newV * t

  config.pos = newPos; config.v = newV
}
function springGoToEnd(config) {
  config.pos = config.dest
  config.v = 0
}

// === generic helpers
function clamp(min, v, max) {
  return v > max ? max : v < min ? min : v
}

// === constant layout metrics. The rest is dynamic
const promptPaddingBottom = 8
const promptSizeY = 47 + promptPaddingBottom // 47 is a magic number. Doesn't show the 3rd line nor cuts the 2nd line on safari, mobile safari and chrome
const prompt1DSizeY = 64 + promptPaddingBottom // size in 1d mode
const boxesGapX = 24, boxesGapY = 24
const boxes1DGapX = 52, boxes1DGapY = 28
const windowPaddingTop = 40
const hitArea1DSizeX = 100 // left and right click region in 1D mode

function colsBoxMaxSizeXF(containerSizeX) {
  const boxMinSizeX = 220 // Make sure that on mobile, this min width is big enough not to show 2 images per row. Also, this won't be respected if view's tiny
  const cols = clamp(1, Math.floor((containerSizeX - boxesGapX) / (boxMinSizeX + boxesGapX)), 7) // half of boxesGapX for container's left and right gap
  const boxMaxSizeX = (containerSizeX - boxesGapX - cols * boxesGapX) / cols
  return {cols, boxMaxSizeX}
}

let data; {
  const windowSizeX = document.documentElement.clientWidth
  const windowSizeY = document.documentElement.clientHeight
  const {cols, boxMaxSizeX} = colsBoxMaxSizeXF(windowSizeX)
  const imgMaxSizeY = boxMaxSizeX + 100 // TODO: adjust this better

  // Image listing
  data = [
    // id/url: <id>, w:px, h:px, caption:text
    {id: '241869ea-0219-4e5e-b7a0-67d9cf9bd98a', w: 1024, h: 1024, prompt: `Lilrobo smoke break`},
    {id: 'b8d73645-f5b1-4538-b1a8-f7491e154e9e', w: 1024, h: 1024, prompt: `Lilrobo Squaretoon`},
    {id: '60b53bdb-ced1-41c3-9326-7ee0c67d2f7c', w: 1024, h: 1024, prompt: `Lilrobo - Street Sketch`},
    {id: '708c694a-80f7-4970-ba28-a949c68bc7c4', w: 1024, h: 1024, prompt: `Lilrobo - Urban Court`},

    {id: 'f8624b53-ce50-469c-9510-630954b7c4ba', w: 1024, h: 1024, prompt: `Mean Gene and The Green Sardines`},
    {id: 'mean-gene-stickr.png', url: 'img/mean-gene-sticker.png', w: 1024, h: 1024, prompt: `Mean Gene and The Green Sardines`},
    {id: '26cf67d3-3b8a-4f50-82be-405feecfda98', w: 1024, h: 1024, prompt: `Free Cigarettes.`},
    {id: 'mean-gene-cig.png', url: 'img/mene-gene-cig.png', w: 1024, h: 1024, prompt: `Free Cigarettes.`},
    {id: 'nymph-guitar', url: 'img/nymph-guitar-min.png', w: 2048, h: 2560, prompt: `Guidance`},
    {id: '17b95f18-6f91-4708-b0c6-5b315fff6252', w: 1024, h: 1536, prompt: `Live at The Kraken - December`},
    {id: 'f94e4123-4a18-49ca-9596-db2b5c143b44', w: 1024, h: 1536, prompt: `Live at The Kraken - November`},
    {id: 'e65dbed6-a64d-4a05-be2e-c8b9c094666e', w: 1024, h: 1536, prompt: `Live at The Kraken - October`},
    {id: 'cb61a2e4-1e49-4a21-af63-d2565f49df9f', w: 1024, h: 1024, prompt: `Dark Alley Dogs - Cyberpunk`},
    {id: '6bae6523-901d-4ec0-b40b-8aa5ccb88fc8', w: 1024, h: 1024, prompt: `Dark Alley Dog - Bio Sketch`},
    {id: '61c81407-c69d-4635-bee0-c8459650f577', w: 1024, h: 1024, prompt: `Dark Alley Dog - Bio Prof Pics`},
    {id: 'cb36a324-e816-4100-98e4-546e49b142be', w: 1024, h: 1024, prompt: `Dark Alley Dog - Logo Design`},
    {id: '2a71785b-f657-48bf-97bb-73abc22c8bf0', w: 1024, h: 1024, prompt: `Lost In Translation`},
    {id: '88a6ca19-d973-469f-a76e-9658eadb8b56', w: 1024, h: 1024, prompt: `Riri`},
    {id: 'riri-2.png', url: 'img/riri-2.png', w: 1024, h: 1024, prompt: `Riri #2`},
    {id: 'riri-3.png', url: 'img/riri-3.png', w: 1024, h: 1024, prompt: `Riri #3`},
    {id: '7d85c5cc-a939-4649-b57d-b192a149d9b1', w: 1024, h: 1024, prompt: `Riri`},
    {id: 'riri-1.png', url: 'img/riri-1.png', w: 1024, h: 1024, prompt: `Riri #1`},
    {id: '599be08f-a987-4f43-9adc-5d7a111024d2', w: 1024, h: 1024, prompt: `Natalie Breed - Waters - Album Cover Art `},
    {id: 'd7afe1a0-6edf-4966-aa6a-d5d329f03162', w: 1024, h: 1024, prompt: `Natalie Breed - Timeless - Album Cover Art`},
    {id: 'bbafcea8-490e-47e2-b34e-4246521be4b9', w: 1024, h: 1024, prompt: `Lianne La Havas - Cyberpunk`},
    {id: 'f4c87ba4-6a29-4608-99d3-4a75e0cae04b', w: 1024, h: 1024, prompt: `Mucha Flower Woman #1`},
    {id: 'f272a403-b919-43ff-8481-3f9091fec52e', w: 1024, h: 1024, prompt: `Mucha Flower Woman #2`},
    {id: '729c6e66-39e7-4fe9-bda9-fc874b390a50', w: 1024, h: 1024, prompt: `Aged Storyteller`},
    {id: 'ee773748-f9df-4e81-906d-5c62d2747755', w: 1024, h: 1024, prompt: `Smirky Friend`},
    {id: 'c88e7da2-7c39-473e-be94-9e0ea101141b', w: 1024, h: 1024, prompt: `Mindful Architecture - #1`},
    {id: 'dc91dbec-82e4-4bfb-b44e-815aa0732692', w: 1024, h: 1024, prompt: `Mindful Architecture - #2`},
    {id: 'cba27d13-c93c-4bff-8c84-2b5d4f90b5c4', w: 1024, h: 1024, prompt: `Mindful Architecture - #3`},
    {id: 'a-placed-filled.png', url: 'img/a-placed-filled.png', w: 1664, h: 1664, prompt: `Mindful Architecture - #4`},
    {id: 'place-dalle-extend.png', url: 'img/place-dalle-extend.png', w: 3456, h: 1664, prompt: `Mindful Architecture + Dalle - #5`},
    {id: 'bc3c8706-0e2e-475b-a445-4aebb27bddf2', w: 1024, h: 1024, prompt: `Stardust`},
    {id: 'stardust-v0.png', url: 'img/stardust-v0.png', w: 1024, h: 1024, prompt: `Adas - Stardust Cover`},
    {id: 'ee1f5be1-6ad9-4631-9c47-7a352a821edd', w: 1024, h: 1024, prompt: `Street Dog`},
    {id: '826ca607-e108-4a11-b64e-fc44fdc7c6f7', w: 1024, h: 1024, prompt: `Street Dog - Flyer #1`},
    {id: '7648ba2d-7186-447e-ab4c-ba68ebcac926', w: 1024, h: 1024, prompt: `Street Dog - Flyer #2`},
    {id: '8b4b7e8d-56c5-4da0-b433-31cde7a0c48b', w: 1024, h: 1024, prompt: `Street Dog - Flyer #3`},

    {id: 'dalle-boat.PNG', url: 'img/dalle-boat.PNG', w: 1664, h: 1664, prompt: `Dalle Boat Flyer`},
    {id: 'dalle-guitar.PNG', url: 'img/dalle-guitar.PNG', w: 1664, h: 1664, prompt: `Dalle Guitar Flyer`},

    {id: '2df25c5a-c022-486d-b8aa-c3615a2daa23', w: 1024, h: 1024, prompt: `Adas - Lost at Sea`},
    {id: 'lost_at_sea-front.png', url: 'img/lost_at_sea-front.png', w: 1664, h: 1664, prompt: `Adas - Lost at Sea Cover`},
    {id: 'lost_at_sea-back.png', url: 'img/lost_at_sea-back.png', w: 1664, h: 1664, prompt: `Adas - Lost at Sea Cover`},
    {id: 'lost-at-sea-album.JPG', url: 'img/lost-at-sea-album.JPG', w: 3024, h: 3024, prompt: `Adas - Lost at Sea Album`},

    {id: 'fffa79bc-ab7f-4185-95eb-8d4480b738e7', w: 1024, h: 1024, prompt: `Adas - Across the Sea #1`},
    {id: '29dcce6b-470e-424b-bf98-bae7450ea6b9', w: 1024, h: 1024, prompt: `Adas - Across the Sea #2`},
    {id: '371bcaa6-2611-45b6-844f-5d50b17ff9a6', w: 1024, h: 1024, prompt: `Adas - Across the Sea #3`},
    {id: '3d82c29e-a660-486e-894e-e2929e1f7934', w: 1024, h: 1024, prompt: `Adas - Across the Sea #3`},


    {id: '15083436-c9a6-4a58-93a7-2b66d06da87a', w: 1024, h: 1024, prompt: `Isometric Music Studio #1`},
    {id: 'e39d3f94-528c-4d3a-b247-dfb2935f4838', w: 1024, h: 1024, prompt: `Isometric Music Studio #2`},
    {id: 'dacafc88-b7f0-43d5-8e16-a9950fe8c903', w: 1024, h: 1024, prompt: `Isometric Music Studio #3`},

    {id: 'aa1ca1bc-4d3f-4436-b5c3-5a907c07718c', w: 1024, h: 1024, prompt: `Red Guitar #1`},
    {id: '29da5feb-2233-403d-a087-cc3586e34bb0', w: 1024, h: 1024, prompt: `Red Guitar #2`},
    {id: '5be90ddb-15a4-4fc4-a5b4-79b0a30b846b', w: 1024, h: 1024, prompt: `Red Guitar #3`},
    {id: '6ee3f553-625c-45cb-88e5-266ce1734712', w: 1024, h: 1024, prompt: `Red Guitar #4`},

    {id: '3b5dd8f2-99ba-4d94-9161-76a38e646440', w: 1024, h: 1024, prompt: `Pretend Cowboys #1`},
    {id: '00004869-b119-41bb-ae24-dc124d085649', w: 1024, h: 1024, prompt: `Pretend Cowboys #2`},
    {id: '1e1c3adb-d4d2-408c-a024-73fa28227eb1', w: 1024, h: 1024, prompt: `Pretend Cowboys #3`},
    {id: '4d3f79c8-6e1b-47cb-8c4c-008b4c38467e', w: 1024, h: 1024, prompt: `Pretend Cowboys #4`},
    {id: 'e284d62e-623f-484e-a3eb-68f33ce506c2', w: 1024, h: 1024, prompt: `Lilrobo Adam - Gundam #1`},
    {id: 'cedb71f8-fc74-42f5-b9be-7435b38adbee', w: 1024, h: 1024, prompt: `Lilrobo Adam - Gundam #2`},

    {id: '92832b32-1085-43d3-b0ed-b006cee26620', w: 1024, h: 1024, prompt: `Handy Man Logo`},

    {id: 'HandyMan', url: 'img/handyman.JPG', w: 1024, h: 1024, prompt: `Handy Man Logo`},

  ].map((d, i) => {
    const ar = d.w / d.h
    const sizeX = Math.min(d.w, boxMaxSizeX, imgMaxSizeY * ar)
    const sizeY = sizeX / ar + promptSizeY
    // upon zooming into 1D mode (big image), swapping out an img src for a higher-res one would cause a flash of blank image in certain cases. Instead, we put the low-res image as a background-image on the container, then the high-res image as a real img on top. Hand-rolled double buffering...
    let node = document.createElement('div')
        node.className = 'box'
        // node.tabIndex = i + 1 // uncomment when dismiss focus isn't this ugly blue hue anymore
        if(d.url) {
          node.style.backgroundImage = `url(${d.url})` // 128 is the next smallest. Too small for retina screens
        }
        else {
          node.style.backgroundImage = `url(https://mj-gallery.com/${d.id}/grid_0_384_N.webp)` // 128 is the next smallest. Too small for retina screens
        }

    let img = document.createElement('img')
        // img.decoding = 'async' // this sucks. It's slower _and_ still janks the UI. No point
    let promptNode = document.createElement('figcaption')
        promptNode.className = 'prompt'
        promptNode.textContent = d.prompt
    node.append(img, promptNode)
    return {
      id: d.id,
      naturalSizeX: d.w,
      ar, // aspect ratio
      sizeX: spring(sizeX),
      sizeY: spring(sizeY), // image + prompt
      x: spring(Math.floor(i / cols) * -windowSizeX - windowSizeX), // unfold from lower left. More visible on long screens
      y: spring(windowSizeY + Math.floor(i / cols) * imgMaxSizeY),
      scale: spring(1),
      fxFactor: spring(20), // for brightness and blur
      node,
    }
  })
}
function springForEach(f) {
  for (let d of data) {
    f(d.sizeX); f(d.sizeY); f(d.x); f(d.y); f(d.scale); f(d.fxFactor) // no different than [a, b, c].forEach(f)
  }
}

// === state. Plus one in the URL's hash
let animatedUntilTime = null
let reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)')
let inputs = {
  pointer: {x: -Infinity, y: -Infinity}, // btw, on page load, there's no way to render a first cursor state =(
  key: null,
  clickedTarget: null,
}

// === events. These (and only these) kick off the render
window.addEventListener('resize', () => scheduleRender())
window.addEventListener('scroll', () => scheduleRender())
window.addEventListener('popstate', () => scheduleRender())
window.addEventListener('keydown', (e) => {
  if (e.code === 'KeyA') scheduleRender(true) // debug
  else if (e.code === 'Escape' || e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
    inputs.key = e.code
    scheduleRender()
  }
})
window.addEventListener('click', (e) => {
  inputs.clickedTarget = e.target
  // needed to update coords even when we already track mousemove. E.g. in Chrome, right click context menu, move elsewhere, then click to dismiss. BAM, mousemove triggers with stale/wrong (??) coordinates... Click again without moving, and now you're clicking on the wrong thing
  inputs.pointer.x = e.pageX - window.scrollX; inputs.pointer.y = e.pageY - window.scrollY
  scheduleRender()
})
window.addEventListener('mousemove', (e) => {
  // when scrolling (which might schedule a render), a container's mousemove doesn't trigger, so the pointer's local coordinates are stale
  // this means we should only use pointer's global coordinates, which is always right (thus the subtraction of scroll)
  inputs.pointer.x = e.pageX - window.scrollX; inputs.pointer.y = e.pageY - window.scrollY
  // btw, pointer can exceed document bounds, e.g. dragging reports back out-of-bound, legal negative values
  scheduleRender()
})

// === static DOM initialization. Just one in this app. The more you have here the more your app looks like a PDF document. Minimize
let dummyPlaceholder = document.createElement('div')
dummyPlaceholder.style.width = '1px' // make it tiny just in case it affects compositing... sigh
document.body.append(dummyPlaceholder)

// === hit testing logic. Boxes' hit area should be static and not follow their current animated state usually (but we can do either)
function hit2DMode(data, pointerX, pointerY) {
  for (let i = 0; i < data.length; i++) {
    let {x, y, sizeX, sizeY} = data[i]
    if (x.dest <= pointerX && pointerX < x.dest + sizeX.dest && y.dest <= pointerY && pointerY < y.dest + sizeY.dest) return i // pointer on this box
  }
  return null
}
function hit1DMode(data, focused, windowSizeX, pointerX) {
  // allow spamming clicks without accidentally clicking on an empty region on left/right side or newly focused image during transition (and dismiss 1D mode)
  return focused > 0 && 0 <= pointerX /* might be -Infinity */ && pointerX <= hitArea1DSizeX ? Math.max(0, focused - 1) // left
    : focused < data.length - 1 && pointerX >= windowSizeX - hitArea1DSizeX ? Math.min(data.length - 1, focused + 1) // right
    : null
}

function render(now) {
  // === step 1: batched DOM reads (to avoid accidental DOM read & write interleaving)
  // excludes scroll bar & invariant under safari pinch zoom
  const windowSizeX = document.documentElement.clientWidth
  // invariant under safari pinch zoom (this way, when zoomed in, we don't occlude away rows outside of the zoomed-in view; if we did, when we zoom out again we wouldn't see those occluded rows until we release our fingers. During safari pinch, no event is triggered so we couldn't have updated the occlusion in real time)
  const windowSizeY = document.documentElement.clientHeight
  const animationDisabled = reducedMotion.matches
  const scrollTop = window.scrollY, scrollLeft = window.scrollX
  const hashImgId = window.location.hash.slice(1)

  let focused = null; for (let i = 0; i < data.length; i++) if (data[i].id === hashImgId) focused = i
  // don't forget top & bottom safari UI chrome sizes when vertically occluding, since they're transluscent so we can't over-occlude by ignoring them
  const UIMaxSizeTop = 100, UIMaxSizeBottom = 150 // random conservative numbers
  const pointerXLocal = inputs.pointer.x + scrollLeft, pointerYLocal = inputs.pointer.y + scrollTop // "local" to document.body (global would be unaffected by scrollX/Y, aka global is relative to the screen)

  // === step 2: handle inputs-related state change
  // keys
  let newFocused =
    inputs.key === 'Escape' ? null
    : inputs.key != null && focused == null ? 0
    : inputs.key === 'ArrowLeft' ? Math.max(0, focused - 1)
    : inputs.key === 'ArrowRight' ? Math.min(data.length - 1, focused + 1)
    : focused
  // pointer
  if (inputs.clickedTarget != null) { // clicked
    if (inputs.clickedTarget.tagName === 'FIGCAPTION') { // select the whole prompt
      let selection = window.getSelection()
      let range = document.createRange()
      range.selectNodeContents(inputs.clickedTarget)
      selection.removeAllRanges()
      selection.addRange(range)
    } else if (focused == null) { // in 2D grid mode. Find the box the pointer's on
      const hit = hit2DMode(data, pointerXLocal, pointerYLocal)
      if (hit != null) newFocused = hit
    } else { // 1D mode
      newFocused = hit1DMode(data, focused, windowSizeX, pointerXLocal)
    }
  }

  // === step 3: calculate new layout & cursor
  const {cols, boxMaxSizeX} = colsBoxMaxSizeXF(windowSizeX)
  let boxesSizeX = [], boxesSizeY = [], rowsTop = [windowPaddingTop] // length: number of rows + 1
  {
    let rowMaxSizeY = 0
    for (let i = 0; i < data.length; i++) {
      let d = data[i]
      const imgMaxSizeY =
        d.ar === 1 ? boxMaxSizeX * 0.85 // square aspect ratio area too big. Shrink it
        : d.ar < 1 ? boxMaxSizeX * 1.05 // vertical images look a bit small. Grow it
        : boxMaxSizeX
      const sizeX = Math.min(d.naturalSizeX, boxMaxSizeX, imgMaxSizeY * d.ar)
      const sizeY = sizeX / d.ar + promptSizeY
      boxesSizeX.push(sizeX)
      boxesSizeY.push(sizeY)
      rowMaxSizeY = Math.max(rowMaxSizeY, sizeY)
      if (i % cols === cols - 1 || i === data.length - 1) { // last box of the row or last box ever
        rowsTop.push(rowsTop.at(-1) + rowMaxSizeY + boxesGapY)
        rowMaxSizeY = 0
      }
    }
  }
  let cursor
  let newScrollTop = scrollTop
  const hoverMagnetFactor = 40
  if (newFocused == null) { // 2D mode
    if (newFocused == null && focused != null) { // just dismissed 1D mode
      const focusedTop = rowsTop[Math.floor(focused / cols)]
      // if the dismissed box isn't fully shown, scroll to it (later after the render code block)
      if (focusedTop <= scrollTop || focusedTop + boxesSizeY[focused] >= scrollTop + windowSizeY) {
        newScrollTop = focusedTop - boxesGapY - 44 // Peek a little higher to show the previous row
        for (let {y} of data) y.pos += newScrollTop - scrollTop // scrolling to the box would jitter the dismiss animation. Compensate by the scroll delta to make it seamless
      }
    }

    for (let i = 0; i < data.length; i++) {
      let d = data[i]
      const sizeX = boxesSizeX[i], sizeY = boxesSizeY[i]
      const currentRow = Math.floor(i / cols)
      const rowMaxSizeY = rowsTop[currentRow + 1] - boxesGapY - rowsTop[currentRow] // this is restoring the rowMaxSizeY info above, kinda weird
      d.sizeX.dest = sizeX
      d.sizeY.dest = sizeY
      d.x.dest = boxesGapX + (boxMaxSizeX + boxesGapX) * (i % cols) + (boxMaxSizeX - sizeX) / 2 // center horizontally
      d.y.dest = rowsTop[currentRow] + (rowMaxSizeY - sizeY) / 2
      d.scale.dest = 1
      d.fxFactor.dest = 1
    }

    const hit = hit2DMode(data, pointerXLocal, pointerYLocal)
    if (hit == null) cursor = 'auto'
    else { // hovering over a box. Make some adjustments
      cursor = 'zoom-in'
      let {x, y, sizeX, sizeY, scale} = data[hit]
      x.dest += (pointerXLocal - (x.dest + sizeX.dest / 2)) / hoverMagnetFactor
      y.dest += (pointerYLocal - (y.dest + sizeY.dest / 2)) / hoverMagnetFactor
      scale.dest = 1.02
    }
  } else { // 1D mode
    const img1DSizeY = windowSizeY - windowPaddingTop - prompt1DSizeY - boxes1DGapY
    const box1DMaxSizeX = windowSizeX - boxes1DGapX * 2 - hitArea1DSizeX * 2

    let currentLeft = hitArea1DSizeX + boxes1DGapX
    for (let i = newFocused - 1; i >= 0; i--) {
      let d = data[i]
      const imgSizeX = Math.min(d.naturalSizeX, box1DMaxSizeX, img1DSizeY * d.ar) * 0.7
      currentLeft -= imgSizeX + boxes1DGapX
    }

    const edgeRubberBandVelocityX =
      inputs.key === 'ArrowLeft' && focused === 0 ? 2000
      : inputs.key === 'ArrowRight' && focused === data.length - 1 ? -2000
      : 0
    for (let i = 0; i < data.length; i++) {
      let d = data[i]
      const imgSizeX = Math.min(d.naturalSizeX, box1DMaxSizeX, img1DSizeY * d.ar) * (i === newFocused ? 1 : 0.7)
      const boxSizeY = imgSizeX / d.ar + prompt1DSizeY
      d.sizeX.dest = imgSizeX
      d.sizeY.dest = boxSizeY
      d.y.dest = scrollTop + Math.max(windowPaddingTop, (windowSizeY - boxSizeY) / 2)
      d.x.dest = i === newFocused ? (windowSizeX - imgSizeX) / 2 : currentLeft
      d.x.v += edgeRubberBandVelocityX / (i === newFocused ? 1 : 4)
      d.scale.dest = 1
      d.fxFactor.dest = 0.2

      currentLeft = i === newFocused ? windowSizeX - hitArea1DSizeX : currentLeft + imgSizeX + boxes1DGapX
    }
    data[newFocused].fxFactor.dest = 1 // center image has no brightness & blur effect

    const hit = hit1DMode(data, newFocused, windowSizeX, pointerXLocal)
    if (hit == null) cursor = 'zoom-out'
    else { // hovering on left or right image
      cursor = 'zoom-in'
      let {x, y, sizeX, sizeY, scale, fxFactor} = data[hit]
      x.dest += (pointerXLocal - (x.dest + sizeX.dest / 2)) / hoverMagnetFactor
      y.dest += (pointerYLocal - (y.dest + sizeY.dest / 2)) / hoverMagnetFactor
      scale.dest = 1.02
      fxFactor.dest = 0.5
    }
  }

  // === step 4: run animation
  let newAnimatedUntilTime = animatedUntilTime == null ? now : animatedUntilTime
  const steps = Math.floor((now - newAnimatedUntilTime) / msPerAnimationStep)
  newAnimatedUntilTime += steps * msPerAnimationStep
  let stillAnimating = false
  if (animationDisabled) springForEach(springGoToEnd)
  else {
    springForEach(s => {
      for (let i = 0; i < steps; i++) springStep(s)
      if (Math.abs(s.v) < 0.01 && Math.abs(s.dest - s.pos) < 0.01) springGoToEnd(s) // close enough, done
      else stillAnimating = true
    })
  }

  // === step 5: render. Batch DOM writes
  for (let i = 0; i < data.length; i++) {
    let d = data[i]
    let {node} = d, img = node.children[0], prompt = node.children[1]
    // occlusion culling, aka only draw what's visible on screen (aka "virtualization")
    if (
      d.y.pos <= newScrollTop + windowSizeY + UIMaxSizeBottom &&
      d.y.pos + d.sizeY.pos >= newScrollTop - UIMaxSizeTop &&
      d.x.pos <= windowSizeX &&
      d.x.pos + d.sizeX.pos >= 0
    ) { // disregard shadow & scaling for now; UIMaxSizeBottom and UIMaxSizeTop are safe bigger values anyway
      node.style.width = `${d.sizeX.pos}px`
      node.style.height = `${d.sizeY.pos}px`
      node.style.transform = `translate3d(${d.x.pos}px,${d.y.pos}px,0) scale(${d.scale.pos})` // safari now anti-aliases for hover, but then zoom in janks on big displays...
      // we can't afford fxFactor & blur for all pics; too expensive for Safari & Chrome. E.g. when zomming out of a photo, keep scrolling; Chrome stops render on Studio Display
      node.style.filter = newFocused != null && i === newFocused - 1 || i === newFocused || i === newFocused + 1
        ? `brightness(${d.fxFactor.pos * 100}%) blur(${Math.max(0, 6 - d.fxFactor.pos * 6)}px)` // blur these 3 only
        : `brightness(${d.fxFactor.pos * 100}%)` // blur of unrelated pics is too fast during transition from/to 1D mode to be seen anyway
      prompt.style.top = `${d.sizeX.pos / d.ar}px` // right below img's sizeY

      if (i === newFocused) {
        node.style.zIndex = data.length + 999 // guaranteed above everything
        prompt.style.overflowY = 'auto'
        prompt.style.height = `${prompt1DSizeY - promptPaddingBottom}px`
        prompt.style.lineClamp = prompt.style.webkitLineClamp = 999
        img.style.display = 'block'
        let src = `https://mj-gallery.com/${d.id}/grid_0.webp`
        if (!stillAnimating && img.src !== src) img.src = src // load the full res image
      } else {
        node.style.zIndex = i + 1 // simple proper z-index management
        prompt.style.overflowY = 'hidden'
        prompt.style.height = `${promptSizeY - promptPaddingBottom}px`
        prompt.style.lineClamp = prompt.style.webkitLineClamp = 2
        img.style.display = 'none' // hide full res image for perf (yes it makes a difference, even on M1, with Studio Display)
      }
      if (node.parentNode == null) document.body.appendChild(node) // if previously absent, add
    } else if (node.parentNode != null) document.body.removeChild(node) // if previously present, remove
  }

  document.body.style.cursor = cursor
  document.body.style.overflowY = newFocused == null ? 'auto' : 'hidden'
  dummyPlaceholder.style.height = `${rowsTop.at(-1)}px`

  // === step 6: update state & prepare for next frame
  if (newScrollTop !== scrollTop) window.scrollTo({top: newScrollTop}) // Chrome has race conditon when expanding the last row of images if scrollTo is called before dummy height setting. Btw this will trigger scroll and next frame's render
  if (newFocused !== focused) {
    window.history.pushState(null, null, `${window.location.pathname}${window.location.search}${newFocused == null ? '' : '#' + data[newFocused].id}`)
  }
  inputs.key = null
  inputs.clickedTarget = null
  animatedUntilTime = stillAnimating ? newAnimatedUntilTime : null

  return stillAnimating
}

scheduleRender()
</script>

</body>

</html>
